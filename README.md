# ACME Card Game API

## Overview
This is a Spring Boot application that provides APIs for managing a deck of cards in a card game.

## Prerequisites
- Java 17 installed on your system
- Docker installed on your system (optional/easiest)

## Running the Application

## 1. Running Locally
To run the application locally, follow these steps:

1. Clone this repository to your local machine.
2. Navigate to the project directory.
3. Make sure you have Java 17 installed.
4. Run the following command to build and run the application:
   ```bash
   gradle bootRun
5. The application will be running at http://localhost:8080
6. View the documentation at http://localhost:8080/swagger-ui/index.html.

## 2. Running on Docker
To run the application in a Docker container:
1. Install Docker:
   - Mac: https://docs.docker.com/desktop/install/mac-install/
   - Windows: https://docs.docker.com/desktop/install/windows-install/
   - Linux: https://docs.docker.com/desktop/install/linux-install/
2. Install Docker Compose: https://docs.docker.com/compose/install/
3. Build the JAR by running:
   ```bash
   gradle build
4. After the JAR is built, run ```docker-compose up --build``` for attached OR ```docker-compose up --build -d``` detached.
5. The application will be running at http://localhost:8080
6. View the documentation at http://localhost:8080/swagger-ui/index.html.

## Design and Tradeoffs:
I built the application to be extensible and capable of modeling any set of cards, not simply the standard 52 deck.  
In the application.yml, I define a deck with the four suits and thirteen ranks of a standard deck.
## Model-View-Controller Pattern
The application follows a standard model-view-controller pattern for the benefit of separating concerns.  
Separating concerns in this manner decreases coupling.
### Models
#### Data Models and Response Models
Models are the basis of application logic. Among the models, I distinguish data models from response models. API requests and responses should always be simpler than the models used for business logic because the ideal of an API is to simplify interactions with the system.  
For example, I defined an Error Response to simplify Exceptions generated by the API such as the Empty Deck Exception.  
##### Concurrent Deck Model
The Deck class encapsulates a CopyOnWriteArrayList structure to represent a Deck of Cards. The data structure  
supports concurrent operations. Each function that interacts with this structure is synchronized to prevent errors and conflicts.
##### Card, Rank, and Suit Models
The Card model encapsulates Rank and Suit models. Each Rank and Suit model has a field called `type`.  
I chose this structure of encapsulation because a more robust implementation would likely validate the types  
and add additional fields and functions, such as `int value` and `compareTo(Object o)`, respectively, for deciding the values  
of a card in a given game and the strength of one card relative to another. Furthermore, an implementation of Rank and Suit  
merely as String fields in the Card model lead to the Card object having too many responsibilities if these features  
were implemented in a later version.
##### Deck Factory
I implemented a version of the Factory Design pattern (non-static due to Spring Bean management) to standardize  
this creation of Card Decks throughout the application. Factory patterns make the code more comprehensible and reduce  
errors and variations in the initialization of objects.
### Controllers
There are two types of controllers in the application: REST Controllers and Services
#### Services
I created a single service called Dealer responsible for the manipulation of data models.
In a later version of the application, the service abstractions will interface with a long-term persistence layer such as a SQL database.
#### REST Controllers
REST controllers are responsible for requests and sending responses in JSON. Separating REST Controllers from  
Services allows engineers to change the API requests and responses without modifying the manipulation of  
data models or persistence layer interactions.
## Libraries
##### Lombok
I used Lombok to reduce boilerplate code.
## Time Complexity
The key data structure is the map of Decks in the Dealer Service. Retrieving a given deck is O(1) complexity.
Given that each Deck is a List of Cards, dealing the top and bottom cards are both O(1) complexity.
## ChatGPT
I used ChatGPT to create the testConcurrentAccessToDeck test.